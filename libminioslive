#!/bin/bash

# Function library for MiniOS utilities
# Author: crims0n. <http://minios.dev>
#

#------- LIBMINIOSLIVE -------

# The `console_colors` function defines a series of variables that correspond to different text colors and styles that can be used in console output.
# Usage:
#   console_colors
#   echo -e "${RED}This is red text${ENDCOLOR}"
#
# The function does not take any arguments, and it needs to be called before using any of the color or style variables in your script.
console_colors() {
    # Standard colors
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"

    # Dark colors
    DARKGRAY="\e[90m"
    DARKRED="\e[38;5;52m"
    DARKGREEN="\e[38;5;22m"

    # Light colors
    LIGHTGRAY="\e[37m"
    LIGHTRED="\e[91m"
    LIGHTGREEN="\e[92m"
    LIGHTYELLOW="\e[93m"
    LIGHTBLUE="\e[94m"
    LIGHTMAGENTA="\e[95m"
    LIGHTCYAN="\e[96m"

    # Neon Colors
    BRIGHTORANGE="\e[38;5;202m"
    BRIGHTGREEN="\e[38;5;46m"

    # Other colors
    ORANGE="\e[38;5;214m"
    GOLD="\e[38;5;220m"
    PURPLE="\e[38;5;93m"
    PINK="\e[38;5;13m"
    TEAL="\e[38;5;6m"
    NAVY="\e[38;5;18m"

    # Text formatting
    BOLD="\e[1m"
    DIM="\e[2m"
    UNDERLINED="\e[4m"
    BLINK="\e[5m"
    REVERSE="\e[7m"
    HIDDEN="\e[8m"

    # Formatting reset
    ENDCOLOR="\e[0m"
}

# A function to read specific variables from a configuration file in Bash.
# Usage:
#   read_config CONFIG_FILE VAR1 VAR2 [...]
#
# Arguments:
#   CONFIG_FILE - Required. This is the path to your configuration file.
#   VAR1, VAR2, etc - Required. The names of variables you wish to read from the configuration file.
#   Note: It's important to specify the variable names you want to read, as the function won't read any variables if none are specified.
read_config() {
    # Enable extended globbing. This is required for the pattern matching of variable names.
    shopt -s extglob

    # The first argument is the configuration file.
    local CONFIG_FILE="${1}"

    # All other arguments are the variable names to look for.
    local KEYLIST="${@:2}"

    # Check if the configuration file is set, exists and is readable.
    if [[ ! "$CONFIG_FILE" ]]; then
        error "No configuration file given"
        exit 1
    fi
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        error "${CONFIG_FILE} is not a file!"
        exit 1
    fi
    if [[ ! -r "${CONFIG_FILE}" ]]; then
        error "${CONFIG_FILE} is not readable!"
        exit 1
    fi

    # Convert the list of variable names to a regex pattern.
    KEYLIST="${KEYLIST// /|}"

    # Read each line of the file.
    while IFS='= ' read -r LHS RHS; do
        # If the variable name is in our list and the value is not empty...
        if [[ "${LHS}" =~ ^(${KEYLIST})$ ]] && [[ -n ${RHS} ]]; then
            # Remove any quotes around the value.
            RHS="${RHS%\"*}"
            RHS="${RHS#\"*}"
            RHS="${RHS%\'*}"
            RHS="${RHS#\'*}"

            # If the value is an array (surrounded by parentheses)...
            if [[ "${RHS}" =~ ^\((.*)\)$ ]]; then
                # Assign the array to the variable.
                eval ${LHS}=\("${BASH_REMATCH[1]}"\)
            else
                # Otherwise, assign the value to the variable.
                eval ${LHS}=\"${RHS}\"
            fi
        fi
    done <<<"$(tr -d '\r' <${CONFIG_FILE})"

    # Disable extended globbing after we're done using it.
    shopt -u extglob
}

# A function for updating a configuration file in bash.
# Usage:
#   update_config CONFIG_FILE [VAR1] [VAR2] [...]
#
# Arguments:
#   CONFIG_FILE - required, this is the path to your configuration file.
#   VAR1, VAR2, etc - the names of variables you wish to update in the configuration file.
#   If variable names are not provided, the function will update all variables found in the file.
update_config() {
    # The configuration file is passed as the first argument
    local CONFIG_FILE="${1}"
    shift

    # Check if the configuration file is set, exists and is readable.
    if [[ ! "$CONFIG_FILE" ]]; then
        error "No configuration file given"
        exit 1
    fi
    if [[ ! -f "${CONFIG_FILE}" ]]; then
        error "${CONFIG_FILE} is not a file!"
        exit 1
    fi
    if [[ ! -r "${CONFIG_FILE}" ]]; then
        error "${CONFIG_FILE} is not readable!"
        exit 1
    fi

    local -a ARGS

    if (($# > 0)); then
        # Use provided variable names
        ARGS=("$@")
    else
        # Extract variable names from the config file
        ARGS=($(grep -v '^#' "${CONFIG_FILE}" | awk -F '=' '{print $1}'))
    fi

    # Iterate over every variable
    for ARG in "${ARGS[@]}"; do
        local -n VAR="${ARG}"
        local NEW_VALUE ELEMENT

        # If the variable is empty, continue to next
        if [[ -z "${VAR[@]}" ]]; then
            continue
        fi

        # Check if the variable is an array or a simple variable
        case "$(declare -p "${ARG}" 2>/dev/null)" in
        "declare -a"*)
            # If it's an array, construct the new value as an array
            NEW_VALUE="${ARG}=("
            for ELEMENT in "${VAR[@]}"; do
                NEW_VALUE+="\"${ELEMENT}\""
                [[ "${ELEMENT}" != "${VAR[-1]}" ]] && NEW_VALUE+=" "
            done
            NEW_VALUE+=")"
            ;;
        *)
            # If it's a simple variable, construct the new value as a string
            NEW_VALUE="${ARG}=\"${VAR}\""
            ;;
        esac

        # If the variable already exists in the configuration file, replace the old value with the new one
        if grep -q "^${ARG}=" "${CONFIG_FILE}"; then
            sed -i "s|^${ARG}=.*|${NEW_VALUE}|" "${CONFIG_FILE}"
        else
            # If the variable does not exist, append the variable and its value to the end of the configuration file
            echo -e "\n${NEW_VALUE}" >>"${CONFIG_FILE}"
        fi
    done

    # Remove empty lines from the configuration file
    #sed -i '/^$/d' "${CONFIG_FILE}"

    # Sort the lines in the configuration file in alphabetical order
    #sort -o "${CONFIG_FILE}" "${CONFIG_FILE}"
}

# A function to read a specific value from a configuration file in Bash.
# Usage:
#   VAR=$(read_config_value CONFIG_FILE VAR)
#
# Arguments:
#   CONFIG_FILE - Required. This is the path to your configuration file.
#   VAR - Required. The name of the variable you wish to read from the configuration file.
read_config_value() {
    if [ ! -f "$1" ]; then
        echo
        return
    fi
    if grep -q "^$2=" $1; then
        grep "^$2=" $1 | cut -d "=" -f 2- | tail -n 1 | sed -e "s/^['\"]//;s/['\"]$//"
    else
        echo
    fi
}

# only allow 'root' to run the script
allow_root_only() {
    if [ $(id -u) -ne 0 ]; then
        error "This script should be run as 'root'!"
        exit 1
    fi

    export HOME=/root
    export LC_ALL=C
}

# Check the original value of the set options.
determine_option_status() {
    local OPTION="${1}"
    local SET_OPTION="SET_${OPTION^^}"

    if [[ $- == *${OPTION}* ]]; then
        eval "${SET_OPTION}='true'"
    else
        eval "${SET_OPTION}='false'"
    fi
}

# Print the current status of the set options.
print_option_status() {
    local OPTION="${1}"
    local SET_OPTION="SET_${OPTION^^}"

    if [[ $- == *${OPTION}* ]]; then
        echo "Option -${OPTION} is currently set."
    else
        echo "Option -${OPTION} is currently unset."
    fi
}

# The toggle_shell_options function temporarily toggles Bash shell options for specific code segments.
# Usage: toggle_shell_options "eu"
# This will toggle the -e and -u options.
#
# Cycle in a script:
#   #!/bin/bash
#   set -eu
#   SET_E=""
#   SET_U=""
#   toggle_shell_options "e"  # Disables "e"
#   # Your code
#   toggle_shell_options "e"  # Re-enables "e"
#
# Remember: Declare SET_x variables for each option you plan to toggle. For example, SET_E for "e".
toggle_shell_options() {
    local OPTIONS="${1}"
    for ((i = 0; i < ${#OPTIONS}; i++)); do
        local OPTION="${OPTIONS:$i:1}"
        local SET_OPTION="SET_${OPTION^^}"

        if [ -z "${!SET_OPTION}" ]; then
            determine_option_status "${OPTION}"
            if [ "${!SET_OPTION}" = "true" ]; then
                set "+${OPTION}"
                #print_option_status "${OPTION}"
                continue
            fi
        fi

        if [ "${!SET_OPTION}" = "true" ]; then
            set "-${OPTION}"
            eval "${SET_OPTION}=''"
            #print_option_status "${OPTION}"
        fi
    done
}

# Display an error message and exit the program.
error() {
    toggle_shell_options u
    local MESSAGE="${1}"

    echo -e "${BOLD}${RED}Error:${ENDCOLOR} ${MESSAGE}" >&2
    toggle_shell_options u
}

#------- LIBMINIOSLIVE -------
